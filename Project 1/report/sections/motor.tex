\begin{filecontents}[overwrite]{./sections/motor_task.tex}
\begin{lstlisting}[language=c,caption=Motor Task, label=list:motor]
void motorTask(void *pvParameters) {
    // Motor task implementation
    BaseType_t status;
    int motorInput;
    float motorDutyCycle;

    while (1) {
        status = xQueueReceive(motor_queue, (void*) &motorInput, portMAX_DELAY);

        if (status != pdPASS) {
            PRINTF("Queue Receive failed!.\r\n");

            while (1)
                ;
        }

        if (prevMotorInput != motorInput) {
            prevMotorInput = motorInput;
            motorDutyCycle = motorInput * 0.025f / 100.0f + 0.0760;
            updatePWM_dutyCycle(FTM_CHANNEL_DC_MOTOR, motorDutyCycle);
            FTM_SetSoftwareTrigger(FTM_MOTOR, true);
        }

        vTaskDelay(1 / portTICK_PERIOD_MS);
    }
}
\end{lstlisting}
\end{filecontents}

\section*{Motor Task}

The motor task controls the DC motor's speed by calculating the PWM duty cycle and controlling the FTM module. The task will wait for and receive messages from the motor queue, and will convert the values received on the queue to the appropriate PWM duty cycle for the FTM module. The motor queue can contain one single byte integer, and the value sent into the queue from the RC task will be between $-100$ and $100$. When the motor task receives an integer from the motor queue, it will compare the motor value with the previous motor value, and if the value has changed it will convert the value to its corresponding PWM duty cycle, and update the FTM module with this duty cycle. We only trigger the FTM module when the motor value has changed as we experienced jittering with the motor when the task triggers the FTM module every time when the motor value has not changed.

\input{sections/motor_task.tex}