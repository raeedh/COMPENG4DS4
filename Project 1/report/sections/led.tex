\begin{filecontents}[overwrite]{./sections/led_task.tex}
\begin{lstlisting}[language=c,caption=LED Task, label=list:led]
void ledTask(void *pvParameters) {
    // LED task implementation
    BaseType_t status;
    float red;
    float green;
    float blue;

    uint8_t led_input[3];

    while (1) {
        status = xQueueReceive(led_queue, (void*) &led_input, portMAX_DELAY);

        if (status != pdPASS) {
            PRINTF("Queue Receive failed!.\r\n");

            while (1)
                ;
        }

        red = (led_input[0] / 255.0) * 100;
        green = (led_input[1] / 255.0) * 100;
        blue = (led_input[2] / 255.0) * 100;

        FTM_UpdatePwmDutycycle(FTM_LED, FTM_RED_CHANNEL, kFTM_EdgeAlignedPwm, (uint8_t) red);
        FTM_SetSoftwareTrigger(FTM_LED, true);

        FTM_UpdatePwmDutycycle(FTM_LED, FTM_GREEN_CHANNEL, kFTM_EdgeAlignedPwm, (uint8_t) green);
        FTM_SetSoftwareTrigger(FTM_LED, true);

        FTM_UpdatePwmDutycycle(FTM_LED, FTM_BLUE_CHANNEL, kFTM_EdgeAlignedPwm, (uint8_t) blue);
        FTM_SetSoftwareTrigger(FTM_LED, true);

        vTaskDelay(1 / portTICK_PERIOD_MS);
    }
}
\end{lstlisting}
\end{filecontents}

\section*{LED Task}

The LED task controls the three LEDs on the board by calculating the PWM duty cycle and controlling the FTM module. The task will wait for and receive messages from the LED queue, and will convert the values received on the queue to the appropriate PWM duty cycle for the FTM module. The LED queue can contain one integer pointer, which points to a three element integer array, and the pointer sent into the queue from the RC task will be to an integer array that contains three values from $0$ to $100$ which correspond to the RGB values of the onboard red, green and blue LEDs. When the LED task receives a pointer from the LED queue, it will convert the values in the array to their corresponding PWM duty cycles, and update the FTM module with this duty cycle, then trigger the FTM module.

\input{sections/led_task.tex}