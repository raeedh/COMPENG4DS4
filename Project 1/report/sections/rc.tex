\begin{filecontents}[overwrite]{./sections/rc_task.tex}
\begin{lstlisting}[language=c,caption=RC Task, label=list:rc]
void rcTask(void *pvParameters) {
    // RC task implementation
    BaseType_t status;

    RC_Values rc_values;
    uint8_t *ptr = (uint8_t*) &rc_values;

    int motor_value;
    int angle_value;
    uint8_t led_value[3];

    while (1) {
        UART_ReadBlocking(RC_UART, ptr, 1);
        if (*ptr != 0x20)
            continue;
        UART_ReadBlocking(RC_UART, &ptr[1], sizeof(rc_values) - 1);
        if (rc_values.header == 0x4020) {

            if (rc_values.ch8 == 1500) {
                motor_value = 0;
            } else {
                switch (rc_values.ch6) {
                    case 1000:
                        motor_value = rc_values.ch8 == 1000 ? (rc_values.ch2 - 1000) / 50 : (rc_values.ch2 - 1000) / -50;
                        led_value[0] = 255;
                        led_value[1] = 0;
                        led_value[2] = 0;
                        break;
                    case 1500:
                        motor_value = rc_values.ch8 == 1000 ? (rc_values.ch2 - 1000) / 20 : (rc_values.ch2 - 1000) / -20;
                        led_value[0] = 255;
                        led_value[1] = 255;
                        led_value[2] = 0;
                        break;
                    case 2000:
                        motor_value = rc_values.ch8 == 1000 ? (rc_values.ch2 - 1000) / 10 : (rc_values.ch2 - 1000) / -10;
                        led_value[0] = 0;
                        led_value[1] = 255;
                        led_value[2] = 0;
                        break;
                }
            }

            angle_value = (rc_values.ch4 - 1500) * 45 / 500;

            status = xQueueSend(motor_queue, (void* ) &motor_value, portMAX_DELAY);
            if (status != pdPASS) {
                PRINTF("Queue Send failed!.\r\n");
                while (1)
                    ;
            }

            status = xQueueSend(angle_queue, (void* ) &angle_value, portMAX_DELAY);
            if (status != pdPASS) {
                PRINTF("Queue Send failed!.\r\n");
                while (1)
                    ;
            }

            status = xQueueSend(led_queue, (void* ) &led_value, portMAX_DELAY);
            if (status != pdPASS) {
                PRINTF("Queue Send failed!.\r\n");
                while (1)
                    ;
            }

            vTaskDelay(1 / portTICK_PERIOD_MS);
        }
    }
}
\end{lstlisting}
\end{filecontents}

\section*{RC Task}

The RC task receives and decodes data coming from the radio receiver, which is connected via UART on the board. The task reads the bytes that are received from the controller through UART, then attempts to match the second byte of the header message (the second byte is used as the 2 byte numbers sent by the RC controller are in big endian). When the second byte of the header message matches, we read the remaining 17 bytes of the RC receiver data packet and try to match the entire header message. When the entire message matches, we will read the values on channels 8 (mapped to forward, stationary, and reverse motor directions), channels 6 (used to control the motor speed between slow, medium, and fast), as well as the joystick data values on channels 1 and 4 (used to adjust the motor speed and servo angle direction).

These channel data values will range from $1000-2000$. Channel 8 will set the motor speed to 0 when the channel is set to 1500, will allow the motor to operate in the forward direction when set to 1000, and will allow the motor to operate in the reverse direction when set to 2000. Channel 6 will allow the motor speed to operate between 0 and a maximum value dependent on the speed setting, as well as enabling the LEDs to operate at a certain colour corresponding to that speed setting. The motor will operate in the slow speed mode when channel 6 is set to 1000, allowing the speed to range from 0 to 20 (controlled by the joystick mapped to channel 1) and set the LED to appear red. The motor will operate in the medium speed mode when channel 6 is set to 1500, allowing the speed to range from 0 to 50 (controlled by the joystick mapped to channel 1) and set the LED to appear yellow. The motor will operate in the fast speed mode when channel 6 is set to 2000, allowing the speed to range from 0 to 1000 (controlled by the joystick mapped to channel 1) and set the LED to appear green. The angle value will range from -45 to 45 depending on the value of channel 4.

The motor speed values will always be mapped a value from -100 to 100, the servo angle values between -45 to 45, and the LED values between 0 to 255. These values are mapped to the expected input ranges for the motor, position, and LED tasks. The values are then sent to the motor, position, and LED queues respectively, where they will be processed by the appropriate tasks.

The RC task is shown in Listing~\ref{list:rc}.

\input{sections/rc_task.tex}